"use strict";(self.webpackChunkwebstir_portal=self.webpackChunkwebstir_portal||[]).push([[4968],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},8871:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"product/plans/testing/architecture-refactor","title":"Tester Architecture Refactor Plan","description":"Overview","source":"@site/docs/product/plans/testing/architecture-refactor.md","sourceDirName":"product/plans/testing","slug":"/product/plans/testing/architecture-refactor","permalink":"/docs/product/plans/testing/architecture-refactor","draft":false,"unlisted":false,"editUrl":"https://github.com/webstir-io/webstir-portal/edit/main/docs/product/plans/testing/architecture-refactor.md","tags":[],"version":"current","lastUpdatedAt":1764454564000,"frontMatter":{},"sidebar":"plans","previous":{"title":"webstir add-route / add-job requirements","permalink":"/docs/product/plans/route-job-generators"},"next":{"title":"Testing Legacy Migration Plan","permalink":"/docs/product/plans/testing/legacy-migration"}}');var t=i(4848),r=i(8453);const l={},o="Tester Architecture Refactor Plan",c={},a=[{value:"Overview",id:"overview",level:2},{value:"Goals",id:"goals",level:2},{value:"Non-Goals",id:"non-goals",level:2},{value:"Background",id:"background",level:2},{value:"Design Tenets",id:"design-tenets",level:2},{value:"Target Architecture",id:"target-architecture",level:2},{value:"Phased Migration",id:"phased-migration",level:2},{value:"Phase 1: Foundations",id:"phase-1-foundations",level:3},{value:"Phase 2: Workflow Migration",id:"phase-2-workflow-migration",level:3},{value:"Phase 3: Cleanup &amp; Tooling",id:"phase-3-cleanup--tooling",level:3},{value:"Phase 4: Performance Optimization",id:"phase-4-performance-optimization",level:3},{value:"Risks &amp; Mitigations",id:"risks--mitigations",level:2},{value:"Success Criteria",id:"success-criteria",level:2},{value:"Resolved Questions",id:"resolved-questions",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"tester-architecture-refactor-plan",children:"Tester Architecture Refactor Plan"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Migrate the bespoke CLI-based test harness to a first-class ",(0,t.jsx)(n.code,{children:".NET"})," test project named ",(0,t.jsx)(n.code,{children:"Tester"})," that executes under ",(0,t.jsx)(n.code,{children:"dotnet test"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Reduce end-to-end runtime by embracing framework-managed parallelism and shared fixtures."}),"\n",(0,t.jsx)(n.li,{children:"Preserve existing workflow coverage (CLI init/build/publish/watch/test) while improving observability and tooling integration."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Adopt xUnit as the canonical framework for all automated tests."}),"\n",(0,t.jsxs)(n.li,{children:["Enable execution via ",(0,t.jsx)(n.code,{children:"dotnet test"})," locally and in CI without compatibility shims."]}),"\n",(0,t.jsx)(n.li,{children:"Maintain the current quick/full suite split through standard trait filtering."}),"\n",(0,t.jsx)(n.li,{children:"Leverage fixtures to minimize redundant workspace initialization and dependency installs."}),"\n",(0,t.jsx)(n.li,{children:"Produce test outputs compatible with IDE tooling (VS, Rider) and common CI reporters."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"non-goals",children:"Non-Goals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Rewriting the CLI workflows themselves."}),"\n",(0,t.jsx)(n.li,{children:"Introducing new workflow scenarios beyond today\u2019s coverage."}),"\n",(0,t.jsx)(n.li,{children:"Building backwards compatibility layers for the legacy runner."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,t.jsxs)(n.p,{children:["The existing ",(0,t.jsx)(n.code,{children:"Tests"})," project (to be replaced by ",(0,t.jsx)(n.code,{children:"Tester"}),") is an executable that orchestrates custom ",(0,t.jsx)(n.code,{children:"ITestSuite"}),"/",(0,t.jsx)(n.code,{children:"ITestCase"})," implementations. It depends on shared helpers (",(0,t.jsx)(n.code,{children:"WorkspaceManager"}),", ",(0,t.jsx)(n.code,{children:"ProcessRunner"}),", CLI wrappers) to bootstrap seed workspaces and run external commands. While it offers rich coverage, the custom harness:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Cannot be invoked via ",(0,t.jsx)(n.code,{children:"dotnet test"}),", limiting IDE tooling and CI integration."]}),"\n",(0,t.jsx)(n.li,{children:"Serializes many scenarios, inflating runtime."}),"\n",(0,t.jsx)(n.li,{children:"Requires bespoke reporting/diagnostics plumbing."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The migration will streamline execution by leaning on xUnit primitives while reusing the domain-specific helpers that interact with the CLI."}),"\n",(0,t.jsx)(n.h2,{id:"design-tenets",children:"Design Tenets"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reuse over rewrite"}),": Keep CLI/process helper code; wrap existing scenarios in xUnit facts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parallel where safe"}),": Organize tests into xUnit collections to isolate stateful workflows and allow read-only checks to run concurrently."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fixture-first setup"}),": Cache expensive setup (seed workspace, dependency install) in collection fixtures; ensure deterministic cleanup."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lean assertions"}),": Replace bespoke assertions with xUnit equivalents except where domain-specific helpers add clarity."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"target-architecture",children:"Target Architecture"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Replace the executable project with ",(0,t.jsx)(n.code,{children:"Tester/Tester.csproj"}),", configured with ",(0,t.jsx)(n.code,{children:"Microsoft.NET.Test.Sdk"}),", xUnit packages, and no ",(0,t.jsx)(n.code,{children:"Main"})," entry point."]}),"\n",(0,t.jsxs)(n.li,{children:["Introduce:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CollectionFixtures"})," for seed workspace preparation and shared CLI context."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Trait"})," constants mirroring ",(0,t.jsx)(n.code,{children:"TestCategory"})," (",(0,t.jsx)(n.code,{children:"Quick"}),", ",(0,t.jsx)(n.code,{children:"Full"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Helper adapters (",(0,t.jsx)(n.code,{children:"WorkflowFact"})," base class) to bridge current ",(0,t.jsx)(n.code,{children:"ITestCase"})," logic into ",(0,t.jsx)(n.code,{children:"[Fact]"})," methods."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Delete legacy abstractions (",(0,t.jsx)(n.code,{children:"ITestSuite"}),", ",(0,t.jsx)(n.code,{children:"ITestRunner"}),", ",(0,t.jsx)(n.code,{children:"TestOutputManager"}),") once all suites are migrated."]}),"\n",(0,t.jsxs)(n.li,{children:["Update scripts (",(0,t.jsx)(n.code,{children:"utilities/format-build.sh"}),", CI definitions) to call ",(0,t.jsx)(n.code,{children:"dotnet test"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"phased-migration",children:"Phased Migration"}),"\n",(0,t.jsx)(n.h3,{id:"phase-1-foundations",children:"Phase 1: Foundations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Add xUnit dependencies and test SDK configuration within the ",(0,t.jsx)(n.code,{children:"Tester"})," project."]}),"\n",(0,t.jsx)(n.li,{children:"Implement shared fixtures for seed workspace / CLI helpers."}),"\n",(0,t.jsx)(n.li,{children:"Port the Init workflow tests as a spike to validate the structure."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"phase-2-workflow-migration",children:"Phase 2: Workflow Migration"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Port remaining workflow suites (Build, Publish, Watch, Help, Add, Framework packages, Package installers) into ",(0,t.jsx)(n.code,{children:"Tester"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Introduce ",(0,t.jsx)(n.code,{children:"[Trait]"})," attributes and ensure quick/full toggles respect current behavior."]}),"\n",(0,t.jsx)(n.li,{children:"Remove corresponding legacy suite classes after each migration."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"phase-3-cleanup--tooling",children:"Phase 3: Cleanup & Tooling"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Remove unused infrastructure (legacy ",(0,t.jsx)(n.code,{children:"Tests"})," runner entry point and supporting wiring) after the ",(0,t.jsx)(n.code,{children:"Tester"})," migration."]}),"\n",(0,t.jsxs)(n.li,{children:["Update developer docs (",(0,t.jsx)(n.code,{children:"README"}),", ",(0,t.jsx)(n.a,{href:"https://github.com/webstir-io/webstir-dotnet/blob/main/.codex/testing.md",children:"orchestrator testing guide"}),", internal runbooks) to reference ",(0,t.jsx)(n.code,{children:"Tester"})," and ",(0,t.jsx)(n.code,{children:"dotnet test"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Adjust CI pipelines and ",(0,t.jsx)(n.code,{children:"format-build.sh"})," to run the new test command."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"phase-4-performance-optimization",children:"Phase 4: Performance Optimization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Enable xUnit parallelization for non-mutating collections."}),"\n",(0,t.jsx)(n.li,{children:"Tune workspace copying/fixtures (e.g., node_modules symlink strategy) to minimize setup time."}),"\n",(0,t.jsx)(n.li,{children:"Add diagnostics/tracing to surface slow tests and refine collection boundaries."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"risks--mitigations",children:"Risks & Mitigations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Workspace contention"}),": Mutating workflows could interfere when parallelized. Mitigate with collection scoping and defensive copy/symlink strategies."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout tuning"}),": CLI commands run longer under load; establish clear defaults and per-test overrides."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CI environment parity"}),": Ensure fixtures handle Linux/macOS differences (symlink support) gracefully."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"success-criteria",children:"Success Criteria"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dotnet test"})," succeeds locally without custom flags by targeting the ",(0,t.jsx)(n.code,{children:"Tester"})," project."]}),"\n",(0,t.jsx)(n.li,{children:"CI pipelines adopt the new command and complete within agreed SLAs."}),"\n",(0,t.jsx)(n.li,{children:"Developers can filter quick/full suites via traits."}),"\n",(0,t.jsx)(n.li,{children:"Legacy harness code is fully removed with no loss of scenario coverage."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"resolved-questions",children:"Resolved Questions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test result artifacts"}),": Tester runs in CI will emit both TRX and Markdown summaries (via ",(0,t.jsx)(n.code,{children:"dotnet test --logger trx"})," and a custom Markdown converter) and upload them as pipeline artifacts for downstream analytics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coverage integration"}),": We will wire Coverlet into Tester once the migration is complete, collecting coverage for ",(0,t.jsx)(n.code,{children:"CLI"})," and ",(0,t.jsx)(n.code,{children:"Engine"})," assemblies with an initial soft threshold (warning-only) to keep the signal actionable without blocking commits."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Upcoming workflow fixtures"}),": Framework package release tests from Phase 6 and future CLI orchestration suites (e.g., backend package smoke tests) will get dedicated collection fixtures to isolate their workspace mutations while allowing lighter suites to run in parallel."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);